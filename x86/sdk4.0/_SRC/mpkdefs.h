/* ****************************************************************************

		24.07.2001 Базовые структуры данных и константы   v 1.1
		-------------------------------------------------------

 **************************************************************************** */

#ifndef TYPES

/*------------------------------------------------------------------------------
				Типы данных
------------------------------------------------------------------------------*/

#define TYPES

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef void far * VPTR;
typedef char far * CPTR;
typedef BYTE far * BPTR;
typedef WORD far * WPTR;
typedef DWORD far * DPTR;

/*------------------------------------------------------------------------------
				 Константы
------------------------------------------------------------------------------*/

#define MAX_N_MR26	8	// Максимально возможное количество 
				// модулей расширения

// Интерфейсы сетевые и последовательные каналы

#define COM0		0	// Соответствует физическому каналу RS232/RS485 №0
#define COM1		1	// Соответствует физическому каналу RS232/RS485 №1
#define ETH0		0	// Соответствует физическому каналу IEEE 802.3 (Ethernet)
#define SER0		1       // Соответствует физическому каналу RS232/RS485 №0


/* ---------------------------------------------------------------------------
			Таблица текущего состояния МР26

Все периферийные каналы: датчики, исполнительные устройства, 
считыватели RD30 имеют возрастающую нумерацию (начиная с нуля) в рамках 
модуля МР26. Связь номеров периферийных каналов и физических разъемов 
модуля МР26 определяется в документации МР26.Т.к. считыватели нумеруются 
подряд (начиная с нуля) поле AddrRD30 теряет свой смысл.

----------------------------------------------------------------------------- */

typedef struct
{
	BYTE AddrMR;	// Сетевой адрес модуля расширения
	BYTE Nin;	// Количество датчиков (дискретных входов)	
	BYTE Nout;      // Количество исполнительных устройств (дискретных выходов)
	BYTE N_RD30;	// Количество считывателей RD30
} MR26;


/* ---------------------------------------------------------------------------
			Таблица текущего состояния МПК-1

Таблица текущего состояния заполняется в функции Init(), один раз 
при старте контроллера МПК-1, и не меняется в ходе его работы.  
Поля отмеченные символом (*) можно изменить в процессе 
работы с помощью функции UpdateStatMPK().
----------------------------------------------------------------------------- */

// константы для полей структуры STAT_MPK

#define SM_RS232	0
#define SM_RS485	1

#define SM_ETH		0
#define SM_SIO		1

#define SM_NOMODEM	0
#define SM_MODEM	1

#define SM_LOCK		1

#define SM_PROG		1

// Биты для поля STAT_MPK.ERROR_IO

#define SM_ERROR_AM186	0x01		// периферия Am186                    
#define SM_ERROR_RS	0x02            // Интерфейс RS232/RS485              
#define SM_ERROR_ETH	0x04            // Интерфейс Ethernet                 
#define SM_ERROR_FLASH	0x08            // FLASH                               
#define SM_ERROR_RTC	0x10            // Часы реального времени
#define SM_ERROR_ID	0x10            // Идентификатор
#define SM_ERROR_I2C	0x20            // Связь с МР26 (I2C)
#define SM_ERROR_MP26_MASK	0xFF00  // модули МР26                    


typedef struct
{
	BYTE RS;	// Выбор типа вспомогательного интерфейса RS232 или RS485. 
			// 0 - RS232, 1 - RS485
	BYTE MIF;       // Выбор активного сетевого интерфейса по умолчанию 
			// 0 - Ethernet, 1 - RS232|RS485.
	BYTE MODEM;	// Выбор режима работы вспомогательного интерфейса. 
			// 0 - последовательный канал работает в режиме прямой 
			// связи, 1 - последовательный канал работает в режиме 
			// модемной связи.
	BYTE LOCK;      // Запрет входа в режим управления (корректировки таблиц)
			// 1 - запрет.
	BYTE PROG;      // Принудительный вход в режим управления(корректировки таблиц))
			// 1 - принудительный вход в режим управления.
	BYTE EXT1;	// Переключение режимов: РАБОЧИЙ/ПРОГРАММАТОР FLASH
			// Перемычка опрашивается начальным
			// загрузчиком. Если EXT1==1 управление передается рабочей
			// Программе, если EXT1==0, то управление передается программатору
			// FLASH. 
	BYTE EXT2;      // Программно опрашиваемая перемычка (для  будущих расширений )
	BYTE N_MR26;	// Количество модулей МР26 обнаруженных на этапе 
			// инициализации контроллера МПК-1. 
	MR26 mr26[MAX_N_MR26];
			// Массив структур данных с описанием конфигурации установленных 
			// МР26 (см. таблицу текущего состояния МР26).
	WORD ERROR_IO;  // Содержит ненулевое значение, если есть хотя бы одна ошибка.
			// Назначение битов:
			// 0 - периферия Am186
			// 1 - Интерфейс RS232/RS485
			// 2 - Интерфейс Ethernet
			// 3- FLASH
			// 4- Часы реального времени/идентификатор
			// 5- Связь с МР26 (I2C)
			// 6..7 - зарезервировано
			// 8..15 - модули МР26
} STAT_MPK;

extern STAT_MPK stat;

/* ---------------------------------------------------------------------------
             	Таблица ошибок последовательного канала
----------------------------------------------------------------------------- */


typedef struct
{
	BYTE Error;   		// Флаг ошибок приема.
				// 0 - нет ошибок
				// 1 - есть ошибка
				// Флаг сбрасывается автоматически при успешном 
				// приеме байта.
	BYTE ErrorCount;        // Счетчик ошибок.
	BYTE ErrorType;         // Тип последней обнаруженной ошибки:
				// 0 - нет ошибки.
				// 1 - Таймаут.
				// 2 - Ошибка четности.
				// 3 - Ошибка фрейма.
				// 4 - Ошибка режима: использование модемных функций 
				//     в режиме MCNF=0 или пакетных функций в режиме MCNF=1
				// 5 - Запрос недопустимого интерфейса (COM1)
} ERROR_COM;

/* ---------------------------------------------------------------------------
		Таблица параметров последовательного канала
----------------------------------------------------------------------------- */

// Биты для поля CONFIG_COM.Mode

#define CONFIG_COM_MCNF	0x01	// Режим работы драйвера последовательного 
				// канала при подключенном модеме: 
				// MCNF=0 -режим приема и передачи пакетов 
				// данных. Функции Wsio(), Rsio() и RsioStat(), 
				// WsioStat() заблокированы.
				// MCNF=1 - режим настройки модема. 
				// Функции пакетной передачи ReadPack и 
				// WritePack заблокированы.

#define CONFIG_COM_W	0x02    // Количество бит данных
				// W=1 - 7 бит
				// W=0 - 8 бит

#define CONFIG_COM_P1	0x08    // Контроль четности
				// P1=1 - контроль четности включен
				// P1=0 - контроль четности выключен
#define CONFIG_COM_P0	0x10    // Тип контроля четности (при P1=1)
				// P0=1 - контроль по четности
				// P0=0 - контроль по не четности
#define CONFIG_COM_HWH	0x100   // Использование аппаратного квитирования (CTS/RTS):
				// HWH=0 - аппаратное квитирование выключено
				// HWH=1 - аппаратное квитирование включено
typedef struct
{
	WORD Mode;		// Режим работы последовательного канала 
	WORD Baud;              // Скорость приема и передачи в битах в секунду 
	WORD Timeout;           // Величина таймаута при приеме байта. Величина таймаута задается в 
				// 10-ти мс. квантах системного таймера  
} CONFIG_COM;

/* ---------------------------------------------------------------------------
		Таблица ошибок сетевого интерфейса
----------------------------------------------------------------------------- */

typedef struct
{
	BYTE Error;		// Флаг ошибок приема.0 - нет ошибок1 - есть ошибка
				// Флаг сбрасывается автоматически при успешном 
				// приеме пакета
	BYTE ErrorCount;        // Счетчик ошибок
	BYTE ErrorTr;           // Тип ошибки:
				// 0 - нет ошибки
				// 1 - Коллизии (для IEEE 802.3 (Ethernet))
				// 2 - Зафиксирован Jabber (для IEEE 802.3 (Ethernet) 
				//	коллизии длятся ддольше 26 мс)
				// 3 - Буфер передачи полон
				// 4 - Запрещение от таблицы разрешенных адресов
				// 5 - Ошибочная длина пакета
	BYTE ErrorRec;          // Тип ошибки:
				// 0 - нет ошибки.
				// 1 - Таймаут.
				// 2 - Ошибка CRC.
				// 3 - Ошибка режима. Использование сетевых функций в режиме MCNF=1
				// 4 - Запрещение от таблицы разрешенных адресов 
				// 5 - принят пакет короче 64 байт (Ethernet)
				// 6 - принят пакет длиннее 1518 байт
} ERROR_NET;


/* ---------------------------------------------------------------------------
			Таблица разрешенных адресов		
----------------------------------------------------------------------------- */

#define MAX_ENTRIES	3	// число элементов в таблице разрешенных адресов

typedef struct
{
	BYTE LogicalAddress[MAX_ENTRIES];	// Логический адрес
	BYTE MACaddress[MAX_ENTRIES][6];	// Физический (MAC) адрес
} rTable;


#endif

